remotes::install_github("https://github.com/isgauper/ordpatt2",build_vignettes = TRUE)
library(ordpatt2)
pi_i2
entropy(c(.5,.5))
entropy(c(.5,.26,.24))
#include <Rcpp.h>
#include <algorithm>
#include <vector>
using namespace Rcpp;
//Display elements of the array
// [[Rcpp::export]]
List perm2(IntegerVector input) {
pi_i
remotes::install_github("https://github.com/isgauper/ordpatt2",build_vignettes = TRUE)
remotes::install_github("https://github.com/isgauper/ordpatt2")
library(ordpatt2)
?OPseq2
set.seed(1234567890, kind="Mersenne-Twister")
x <- rnorm(1000) # white noise
OPseq2(x, emb=4, lag=1)
library(StatOrdPattHxC)
OPseq2(x, emb=4, lag=1) ->a
OPseq(x, emb=4, lag=1) ->b
sum(a!=b)
library(ordpatt2)
library(microbenchmark)
x <- rnorm(10000)
microbenchmark(
ordpatt2::OPseq2(x, 4, lag=2),
StatOrdPattHxC::OPseq(x, 4, lag=2)
)
?switch
library(StatOrdPattHxC)
browseVignettes("StatOrdPattHxC")
devtools::install_github("arey1911/StatOrdPattHxC", build_vignettes = TRUE, force=TRUE)
library(StatOrdPattHxC)
browseVignettes("StatOrdPattHxC")
int row = 0;
library(Rcpp)
sourceCpp("C:/Users/Emmy/Documents/ordpatt2_pkg/ordpatt2/src/perm2_v2.cpp")
perm2_v2(0:5)
perm2_v2(0:5)->p2
sourceCpp("C:/Users/Emmy/Documents/ordpatt2_pkg/ordpatt2/src/perm2.cpp")
perm2(0:5)->p1
p1==p2
sum(p1!=p2)
sourceCpp("C:/Users/Emmy/Documents/ordpatt2_pkg/ordpatt2/src/perm2_v2.cpp")
perm2_v2(0:4)->p4_2
perm2(0:4)->p4
sum(p4_2!=p4)
p4_2
pi_i2(0:5)
pi_i2(c(4,2,3,1))
pi_i2(c(4,2,3,1,0))
pi_i2(c(2,3,1,0))
pi_i2(c(2,3,0,1))
sourceCpp("C:/Users/Emmy/Documents/ordpatt2_pkg/ordpatt2/src/pi_i2_v2.cpp")
sourceCpp("C:/Users/Emmy/Documents/ordpatt2_pkg/ordpatt2/src/pi_i2_v2.cpp")
sourceCpp("C:/Users/Emmy/Documents/ordpatt2_pkg/ordpatt2/src/pi_i2_v2.cpp")
sourceCpp("C:/Users/Emmy/Documents/ordpatt2_pkg/ordpatt2/src/pi_i2_v2.cpp")
ind_pos
ind_pos <- function(part){
v <- sort(unique(part))
count <- 0
pos <- vector()
for (i in 1:length(v)){
id <- which(part == v[i])
for (j in 1:length(id)){
count <- count + 1
pos[id[j]] <- count
}
}
return(pos-1)
}
TS_temp = lynx
el <- length(TS_temp) - emb + 1
el <- length(TS_temp) - emb_temp + 1
emb_temp = 4
el <- length(TS_temp) - emb_temp + 1
seqOP_temp <- vector()
for (i in 1:el){
seqOP_temp[i] <- pi_i(ind_pos(TS_temp[i:(i + emb_temp - 1)]))
}
pi_i <- function(pat){
a <- length(pat) - 1
op <- as.data.frame(perm(0:a))
return(row.match(pat, op))
}
seqOP_temp <- vector()
for (i in 1:el){
seqOP_temp[i] <- pi_i(ind_pos(TS_temp[i:(i + emb_temp - 1)]))
}
perm <- function(v) {
n <- length(v)
if (n == 1) v
else {
X <- NULL
for (i in 1:n) X <- rbind(X, cbind(v[i], perm(v[-i])))
X
}
}
seqOP_temp <- vector()
for (i in 1:el){
seqOP_temp[i] <- pi_i(ind_pos(TS_temp[i:(i + emb_temp - 1)]))
}
library(prodlim)
seqOP_temp <- vector()
for (i in 1:el){
seqOP_temp[i] <- pi_i(ind_pos(TS_temp[i:(i + emb_temp - 1)]))
}
ind_pos(TS_temp[i:(i + emb_temp - 1)])
i=3
ind_pos(TS_temp[i:(i + emb_temp - 1)])
i=2
ind_pos(TS_temp[i:(i + emb_temp - 1)])
seqOP_temp
ip = ind_pos(TS_temp[i:(i + emb_temp - 1)])
pi_i(ip)
pi_i2_v2(ip)
seqOP_temp_v2 <- vector()
for (i in 1:el){
seqOP_temp_v2[i] <- pi_i2_v2(ind_pos(TS_temp[i:(i + emb_temp - 1)]))
}
sum(seqOP_temp != seqOP_temp_v2)
remotes::install_github("https://github.com/isgauper/ordpatt2",
INSTALL_opts = c("--install-tests"),build_vignettes = TRUE)
library(ordpatt2)
test_path <- system.file("tests/testthat", package = "ordpatt2")
test_path
testthat::test_dir(test_path)
setwd("~/ordpatt2_pkg/ordpatt2")
library(ordpatt2)
OPprob2(lynx)
OPprob2(lynx,
emb=Inf)
OPprob2(lynx,
emb=-3)
OPprob2(lynx,
emb=-Inf)
e =3
e > 3 || e < inf
e > 3 || e < Inf
test_that("Test for error if emb = Inf", {
expect_error(OPprob2(list(lynx),emb=Inf), "'emb' must be greater than 1 and less than Inf")
})
library(testthat)
test_that("Test for error if emb = Inf", {
expect_error(OPprob2(list(lynx),emb=Inf), "'emb' must be greater than 1 and less than Inf")
})
x <- rnorm(1000)
test_that("Test for error if emb = Inf", {
expect_error(OPprob2(x,emb=Inf), "'emb' must be greater than 1 and less than Inf")
})
OPprob2(x,emb=Inf)
#' Function that finds the Ordinal Patterns probabilities in a time series for a given embedding dimension
#'
#' @usage OPprob2(TS, emb)
#' @param TS time series of length \eqn{n-m+1}
#' @param emb embedding dimension \eqn{m}
#' @returns a sequence of \eqn{n} patterns
#'
#' @name OPprob2
#'
#' @import tibble
#' @import dplyr
#' @import prodlim
#' @import ggplot2
#' @import ggthemes
#'
#' @export
#'
#' @examples
#' set.seed(1234567890, kind="Mersenne-Twister")
#' x <- rnorm(1000) # white noise
#' y <- mov.av(x, order=11) # smoothed with moving averages
#' OPprob2(x, emb=4)
#' OPprob2(y, emb=4)
utils::globalVariables("OP")
OPprob2 <- function(TS, emb, ...){
UseMethod("OPprob2")
}
# Default method
#' @export
OPprob2.default <- function(TS, emb, ...){
# TS must not contain characters
if (!all(sapply(TS, is.numeric))) {
stop("All columns in 'TS' must be numeric.")
}
# TS must not be a list
if (is.list(TS)){
stop("'TS' must not be a list")
}
# emb must be greater than 1 and less than Inf
if (emb < 2 || emb < Inf){
stop("'emb' must be greater than 1 and less than Inf")
}
# emb must be an integer
if ( emb %% 1 != 0){
stop("'emb' must be an integer")
}
op <- tibble::tibble(
OP = factor(OPseq2(TS, emb), levels = 1:factorial(emb))
)
fr <- op %>% count(OP, .drop = FALSE)
probs <- fr$n / sum(fr$n)
result <- as.numeric(probs)
class(result) <- c("my_OPprob", "numeric")
return(result)
}
# print without method and class label
#' @export
print.my_OPprob <- function(x, ...) {
y <- as.numeric(x)
print(y)
}
# plot histogram of proportion of patterns
#' @export
plot.my_OPprob <- function(x, ...) {
# get probabilities
probs <- as.numeric(x)
# create data frame
df <- data.frame(
index = 1:length(probs),
y = probs
)
# plot histogram
p <- ggplot2::ggplot(df, aes(x = index, y = y)) +
geom_col(aes(fill="data"),col="black") +
xlab("Pattern") +
ylab("Proportion of patterns") +
ggthemes::theme_tufte() +
theme(legend.position = "none")
print(p)
}
test_that("Test for error if emb = Inf", {
expect_error(OPprob2(x,emb=Inf), "'emb' must be greater than 1 and less than Inf")
})
OPprob2(x,emb=Inf)
#' Function that finds the Ordinal Patterns probabilities in a time series for a given embedding dimension
#'
#' @usage OPprob2(TS, emb)
#' @param TS time series of length \eqn{n-m+1}
#' @param emb embedding dimension \eqn{m}
#' @returns a sequence of \eqn{n} patterns
#'
#' @name OPprob2
#'
#' @import tibble
#' @import dplyr
#' @import prodlim
#' @import ggplot2
#' @import ggthemes
#'
#' @export
#'
#' @examples
#' set.seed(1234567890, kind="Mersenne-Twister")
#' x <- rnorm(1000) # white noise
#' y <- mov.av(x, order=11) # smoothed with moving averages
#' OPprob2(x, emb=4)
#' OPprob2(y, emb=4)
utils::globalVariables("OP")
OPprob2 <- function(TS, emb, ...){
UseMethod("OPprob2")
}
# Default method
#' @export
OPprob2.default <- function(TS, emb, ...){
# TS must not contain characters
if (!all(sapply(TS, is.numeric))) {
stop("All columns in 'TS' must be numeric.")
}
# TS must not be a list
if (is.list(TS)){
stop("'TS' must not be a list")
}
# emb must be greater than 1 and less than Inf
if (emb < 2 ){
stop("'emb' must be greater than 1 and less than Inf")
}
# emb must be greater than 1 and less than Inf
if (emb == Inf ){
stop("'emb' must be greater than 1 and less than Inf")
}
# emb must be an integer
if ( emb %% 1 != 0){
stop("'emb' must be an integer")
}
op <- tibble::tibble(
OP = factor(OPseq2(TS, emb), levels = 1:factorial(emb))
)
fr <- op %>% count(OP, .drop = FALSE)
probs <- fr$n / sum(fr$n)
result <- as.numeric(probs)
class(result) <- c("my_OPprob", "numeric")
return(result)
}
# print without method and class label
#' @export
print.my_OPprob <- function(x, ...) {
y <- as.numeric(x)
print(y)
}
# plot histogram of proportion of patterns
#' @export
plot.my_OPprob <- function(x, ...) {
# get probabilities
probs <- as.numeric(x)
# create data frame
df <- data.frame(
index = 1:length(probs),
y = probs
)
# plot histogram
p <- ggplot2::ggplot(df, aes(x = index, y = y)) +
geom_col(aes(fill="data"),col="black") +
xlab("Pattern") +
ylab("Proportion of patterns") +
ggthemes::theme_tufte() +
theme(legend.position = "none")
print(p)
}
OPprob2(x,emb=Inf)
test_that("Test for error if emb = Inf", {
expect_error(OPprob2(x,emb=Inf), "'emb' must be greater than 1 and less than Inf")
})
#' Function that finds the OP sequence of a time series, given the
#' embedding dimension and lag
#'
#' @param TS time series
#' @param emb embedding dimension
#' @param lag time lag (default value: 1)
#'
#' @importFrom stats rnorm
#' @export
#'
#' @examples
#' # Generate a time series and compute its ordinal patterns
#' set.seed(1234567890, kind="Mersenne-Twister")
#' x <- rnorm(1000) # white noise
#' OPseq2(x, emb=4, lag=1)
#'
OPseq2 <- function(TS, emb, lag=1){
# TS must not contain characters
if (!all(sapply(TS, is.numeric))) {
stop("All columns in 'TS' must be numeric.")
}
# TS must not be a list
if (is.list(TS)){
stop("'TS' must not be a list")
}
# emb must be greater than 1 and less than Inf
if (emb < 2 ){
stop("'emb' must be greater than 1 and less than Inf")
}
# emb must be greater than 1 and less than Inf
if (emb == Inf ){
stop("'emb' must be greater than 1 and less than Inf")
}
# emb must be an integer
if ( emb %% 1 != 0){
stop("'emb' must be an integer")
}
# lag must be greater than 0
if (!(lag > 0) ){
stop("'lag' must be greater than 0")
}
# lag must be an integer
if ( lag %% 1 != 0){
stop("'lag' must be an integer")
}
# number of OP for lag = 1
el <- length(TS) - emb + 1
# OP sequence for lag = 1
seqOP <- vector()
for (i in 1:el){
seqOP[i] <- pi_i2(ind_pos(TS[i:(i + emb - 1)]))
}
# OP sequence for the given lag
return(seqOP[seq(1, el, lag)])
}
test_that("Test for error if emb = Inf", {
expect_error(OPseq2(x,emb=Inf), "'emb' must be greater than 1 and less than Inf")
})
OPseq2(x,emb=4,lag=Inf)
?OPseq2
y = c(1,2,3,4,5,)
y = c(1,2,3,4,5,6)
OPseq2(y,emb=2,lag=1)
y = rnorm(1000)
OPseq2(y,emb=2,lag=1)
?OPseq2
test_that("Test whether outputs are the same as StatOrdPattHxC", {
expect_equal(
OPseq2(x, emb=4, lag=2),
StatOrdPattHxC::OPseq(x, emb=4, lag=2)
)
expect_equal(
OPseq2(lynx, emb=5, lag=3),
StatOrdPattHxC::OPseq(lynx, emb=5, lag=3)
)
})
library(ordpatt2)
OPseq2(y,emb=2,lag=1)
