ind_pos
?meanC
?perm
?pi_i
?pval
?sigma2q
?varC
?ind_pos
?MovingAverage
?mov.av
?LinfLsup
?lynx
?mov.av
?LinfLsup
?Sigma
Sigma(linux,emb)
sigma2q(linux,2)
linux
lynx
Sigma(lynx,emb)
sigma(lynx,emb)
sigma2q(lynx,emb)
sigma2q(lynx,2)
Sigma(lynx,2)
??statordPattHxC
?mov.av
mov.av(lynx)
LinfLsup
HFisher
?HFisher
?HRenyi
?HFisher
?HRenyi
?HTsallis
?HShannon
?OPprob
set.seed(1234567890, kind="Mersenne-Twister")
x <- rnorm(1000) # white noise
y <- mov.av(x, order=11) # smoothed with moving averages
OPprob(x, emb=4)
OPprob(y, emb=4)
?OPseq
OPprob(y,emb=4)
OPseq(y,emb=4)
4*3*2*1
OPseq(y,emb=3)
?StatComplexity
?entropicTest
x1 <- mov.av(rnorm(5000), order = 31)
class(x1)
x1
mode(x1)
typeof(x1)
attributes(x1)
str(x1)
OPprobs.wn <- OPprob(wn, emb=4)
wn <- rnorm(4970) # white noise, same size as the vectors above
OPprobs.wn <- OPprob(wn, emb=4)
type(wn)
class(wn)
str(wn)
str(OPprobs.wn)
class(OPprobs.wn)
HShannon(OPprobs.wn)
class(HShannon(OPprobs.wn))
a<-sigma2q(wn[1:1000], emb = 4, ent = "S")
class(a)
a
entropicTest(wn, x1, emb=4, ent="S")
entropicTest(wn, x1, emb=4, ent="S")->b
class(b)
class(StatComplexity(OPprob(wnsub, emb=D))
)
wnsub <- wn
class(StatComplexity(OPprob(wnsub, emb=D))
)
D <- 4
class(StatComplexity(OPprob(wnsub, emb=D))
)
StatComplexity(OPprob(wnsub, emb=D))
?meanC
?pval
library("StatOrdPattHxC")
??StatORdPattHxC
install.packages(microbenchmark)
install.packages("microbenchmark")
microbenchmark(
mov.av(rnorm(5000), order = 31),
times = 100
)
library(microbenchmark)
microbenchmark(
mov.av(rnorm(5000), order = 31),
times = 100
)
lynx
microbenchmark(
mov.av(rnorm(500000), order = 31),
times = 100
)
system.time(
mov.av(rnorm(500000), order = 31)
)
system.time(
mov.av(rnorm(5000000), order = 31)
)
x <- rnorm(5000000)
system.time(
mov.av(x, order = 31)
)
times <- replicate(100, {
system.time(mov.av(x, order = 31))["elapsed"]
})
mean(times)
x1 <- mov.av(x)
times <- replicate(100, {
system.time(OPprob(x1, emb=4))["elapsed"]
})
times <- replicate(100, {
system.time(mov.av(x, order = 31))["elapsed"]
})
mean(times)
x1 <- mov.av(x)
times <- replicate(100, {
system.time(OPprob(x1, emb=4))["elapsed"]
})
# Timeseries to use
x <- rnorm(500000)
x1 <- mov.av(x)
length(x)
x1 <- mov.av(x)
length(x1)
times <- replicate(100, {
system.time(OPprob(x1, emb=4))["elapsed"]
})
OPprb.x <- OPprob(x, emb=4)
OPprb.x1 <- OPprob(x1, emb=4)
times <- replicate(100, {
system.time(HShannon(OPprb.x))["elapsed"]
})
mean(times)
times <- replicate(100, {
system.time(HShannon(OPprb.x1))["elapsed"]
})
mean(times)
times <- replicate(100, {
system.time(HTsallis(OPprb.x))["elapsed"]
})
mean(times)
times <- replicate(100, {
system.time(HTsallis(OPprb.x1))["elapsed"]
})
mean(times)
times <- replicate(100, {
system.time(HRenyi(OPprb.x))["elapsed"]
})
mean(times)
times <- replicate(100, {
system.time(HRenyi(OPprb.x1))["elapsed"]
})
mean(times)
times <- replicate(100, {
system.time(HFisher(OPprb.x))["elapsed"]
})
mean(times)
times <- replicate(100, {
system.time(HFisher(OPprb.x1))["elapsed"]
})
mean(times)
x1 <- mov.av(x)
times <- replicate(100, {
system.time(OPprob(x1, emb=4))["elapsed"]
})
times <- replicate(100, {
system.time(mov.av(x, order = 31))["elapsed"]
})
mean(times)
times <- replicate(100, {
system.time(sigma2q(x, emb = 4, ent = "S")))["elapsed"]
times <- replicate(100, {
system.time(sigma2q(x, emb = 4, ent = "S"))["elapsed"]
})
times <- replicate(100, {
system.time(entropicTest(x, x1, emb=4, ent="S"))["elapsed"]
})
# Timeseries to use
x <- rnorm(500000)
x1 <- mov.av(x)
library("StatOrdPattHxC")
x1 <- mov.av(x)
OPprb.x <- OPprob(x, emb=4)
OPprb.x1 <- OPprob(x1, emb=4)
times <- replicate(100, {
system.time(entropicTest(OPprb.x))["elapsed"]
})
entropicTest(OPprb.x)
entropicTest(OPprb.x, emb=4)
StatComplexity(OPprb.x)
times <- replicate(100, {
system.time(StatComplexity(OPprb.x), emb=4)["elapsed"]
})
times <- replicate(100, {
system.time(StatComplexity(OPprb.x, emb=4))["elapsed"]
})
times <- replicate(100, {
system.time(StatComplexity(OPprb.x))["elapsed"]
})
mean(times)
library("StatOrdPattHxC")
?asymptoticVarHShannonMultinomial
asymptoticVarHShannonMultinomial(.5,100)
asymptoticVarHShannonMultinomial(.5,1)
asymptoticVarHShannonMultinomial(c(.5,.5),100)
asymptoticVarHShannonMultinomial(c(.25,.75),100)
asymptoticVarHShannonMultinomial(c(.3,.1,.1,.2,.4),100)
?meanC
meanC(c(.3,.1,.1,.2,.4),100)
asymptoticVarHShannonMultinomial(c(.3,.1,.1,.2,.3),100)
meanC(c(.3,.1,.1,.2,.3),100)
meanC(c(.3,.1,.1,.2,.3),1000)
?varC
varC(c(.1,.1,.1,.1,.1,.1,.3,.1),1000)
times <- replicate(100, {
system.time(varC(c(.1,.1,.1,.1,.1,.1,.3,.1),1000))["elapsed"]
})
mean(times)
library("ordinalpattern")
install.packages("ordinalpattern")
??ordinalpatterns
??ordinalpattern
example(countingpatterns)
countingpatterns(rnorm(100))
countingpatterns(rnorm(100))
library(ordinalpattern)
countingpatterns(rnorm(100))
OPprob(rnorm(100),3)
library(StatOrdPattHxC)
OPprob(rnorm(100),3)
22+14+14+17+17+18+13
22/115
x<-rnorm(100)
countingpatterns(x)
OPprob(x,3)
19+15+16+16+16+16
19/98
15/98
16/98
?patternchange
set.seed(1066)
a1 <- cbind(rnorm(100),rnorm(100))
a2 <- rmvnorm(100,sigma=matrix(c(1,0.8,0.8,1),ncol=2))
A <- rbind(a1,a2)
testresult <- patternchange(A[,1],A[,2])
plot(testresult)
testresult
patternchange(a1,a2)
patternchange(a1,a2)
?patterndependence
set.seed(1066)
patternobj <- patterndependence(rnorm(100),rnorm(100))
plot(patternobj)
patternobj
?patterndependence
patternobj <- patterndependence(x,x)
plot(patternobj)
patternobj
?pval
pval(x,x)
pval(x,x,4)
pval(x,x,3)
y <-rnorm(100)
pval(x,y,3)
patterndependence(x,y)
?OPprob
?OPseq
?StatComplexity
?asymptoticVarHShannonMultinomial
?entropicTest
entropicTest(x,y,3)
?meanC
?pval
pval(x,y,3)
patterndependence(x,y)
?sigma2q
?varC
install.packages("opa")
library(opa)
library(StatOrdPattHxC)
?HShannon
?HRenyi
?HShannon
install.packages("sloop")
library(sloop)
?HTsallis
?HFisher
?HRenyi
f <- factor(c("a", "b", "c"))
typeof(f)
class(f)
attributes(f)
unclass(f)
ftype(print)
ftype(str)
ftype(HRenyi)
ftype(unclass)
print(f)
print(unclass(f))
?entropy
??entropy
?entro000c
# Create and assign class in one step
entropy <- structure(list(), class = "my_class")
entropy <- list()
class(entropy) <- "my_class"
class(entropy)
inherits(entropy,"my_class")
inherits(entropy,"your_class")
class(entropy)
inherits(entropy,"my_entropy")
# Create and assign class in one step
entropy <- structure(list(), class = "my_entropy")
inherits(entropy,"my_entropy")
inherits(entropy,"your_class")
class(entropy)
new_factor <- function(x = integer(), levels = character()) {
stopifnot(is.integer(x))
stopifnot(is.character(levels))
structure(
x,
levels = levels,
class = "factor"
)
}
newfactor(4, "b")
new_factor <- function(x = integer(), levels = character()) {
stopifnot(is.integer(x))
stopifnot(is.character(levels))
structure(
x,
levels = levels,
class = "factor"
)
}
newfactor(4, "b")
new_factor(4, "b")
class(4)
new_factor(0:4, "b")
integer(4)
install.packages("mylm")
averages.default <- function(x, method = c("mean", "median", "mode"), ...) {
method <- match.arg(method)
if (!is.numeric(x)) stop("x must be numeric")
result <- switch(
method,
mean   = {
sum(x) / length(x)
},
median = median(x, ...),
mode   = {
ux <- unique(x)
ux[which.max(tabulate(match(x, ux)))]
}
)
# Wrap result in an object with class "averages"
structure(result, class = "averages", method = method)
}
print.averages <- function(x, ...) {
cat("Average (", attr(x, "method"), "): ", unclass(x), "\n", sep = "")
}
x <- c(1, 2, 2, 3, 4, 5)
averages(x, method = "mean")
print.averages.default <- function(x, ...) {
cat("Average (", attr(x, "method"), "): ", unclass(x), "\n", sep = "")
}
, 3, 4, 5)
averages.default(x, method = "mean")
# Average (mean): 2.833333
averages.default(x, method = "median")
averages.default(x, method = "mode")
md <- averages.default(x, method = "mode")
md
attributes(md)
md[1]
?HFisher
remotes::install_github("https://github.com/isgauper/ordpatt2" ,build_vignettes =
TRUE)
library(ordpatt2)
browseVignettes("ordpatt2")
devtools::build(vignettes = TRUE)
remotes::install_github("https://github.com/isgauper/ordpatt2",build_vignettes = TRUE)
library(ordpatt2)
broweVignettes("ordpatt2")
browseVignettes("ordpatt2")
entropy()
set.seed(1234567890, kind="Mersenne-Twister")
x <- rnorm(1000) # white noise
y <- mov.av(x, order=51) # smoothed with moving averages
# Ordinal Patterns
op.wn.4 <- OPprob2(x, emb=4)
op.ma.4 <- OPprob2(y, emb=4)
# Fisher information measures
entropy(op.wn.4, "Fisher")
entropy(op.wn.4, "Renyi")
set.seed(1234567890, kind="Mersenne-Twister")
x <- rnorm(1000) # white noise
y <- mov.av(x, order=11) # smoothed with moving averages
opx <- OPprob2(x, emb=4)
opy <- OPprob2(y, emb=4)
opy
plot(opx)
plot(opy)
devtools::install_github("https://github.com/isgauper/ordpatt2", INSTALL_opts = "--install-tests")
remotes::install_github("https://github.com/isgauper/ordpatt2", INSTALL_opts = c("--install-tests"))
system.file("tests", package = "ordpatt2")
tools::testInstalledPackage("ordpatt2")
test_check("ordpatt2")
library(ordpatt2)
system.file("tests", package = "ordpatt2")
tools::testInstalledPackage("ordpatt2")
testthat::test_file("tests/testthat/test-entropy.R")
devtools::document()
setwd("~/ordpatt2_pkg/ordpatt2")
devtools::document()
setwd("~/ordpatt2_pkg/ordpatt2")
remotes::install_github("https://github.com/isgauper/ordpatt2", INSTALL_opts = c("--install-tests"))
devtools::document()
devtools::document()
usethis::use_test("name")
usethis::use_test("entropy")
devtools::test()
remotes::install_github("https://github.com/isgauper/ordpatt2", INSTALL_opts = c("--install-tests"))
devtools::document()
set.seed(123)  # for reproducibility
x <- rnorm(1000)
# Get ordinal pattern probabilities
op.wn.4 <- StatOrdPattHxC::OPprob(x, emb = 4)
op.wn.5 <- StatOrdPattHxC::OPprob(x, emb = 5)
expect_equal(
OPprob2(op.wn.4),
StatOrdPattHxC::OPprob(op.wn.4)
)
library(testthat)
set.seed(123)  # for reproducibility
x <- rnorm(1000)
# Get ordinal pattern probabilities
op.wn.4 <- StatOrdPattHxC::OPprob(x, emb = 4)
op.wn.5 <- StatOrdPattHxC::OPprob(x, emb = 5)
expect_equal(
OPprob2(op.wn.4),
StatOrdPattHxC::OPprob(op.wn.4)
)
library(ordpatt2)
set.seed(123)  # for reproducibility
x <- rnorm(1000)
# Get ordinal pattern probabilities
op.wn.4 <- StatOrdPattHxC::OPprob(x, emb = 4)
op.wn.5 <- StatOrdPattHxC::OPprob(x, emb = 5)
expect_equal(
OPprob2(op.wn.4),
StatOrdPattHxC::OPprob(op.wn.4)
)
browseVignettes("ordpatt2")
set.seed(123)  # for reproducibility
x <- rnorm(1000)
expect_equal(
OPprob2(x, emb=4),
StatOrdPattHxC::OPprob(x, emb=4)
)
OPprob2(x,emb=4)
class(OPprob2(x,emb=4))
OPprob2(x,emb=4)[1]
StatOrdPattHxC::OPprob(x, emb=4)
expect_equal(
as.numeric(OPprob2(x, emb=4)),
StatOrdPattHxC::OPprob(x, emb=4)
)
OPprob2(x, emb=5))->opx
OPprob2(x, emb=5)->opx
opx[1]
opx$
test_that("Test whether outputs are the same as StatOrdPattHxC", {
# Get test data
set.seed(123)  # for reproducibility
x <- rnorm(1000)
expect_equal(
as.numeric(OPprob2(x, emb=4)),
StatOrdPattHxC::OPprob(x, emb=4)
)
expect_equal(
as.numeric(OPprob2(x, emb=5)),
StatOrdPattHxC::OPprob(x, emb=5)
)
})
test_that("Test whether missing embedding dimension returns an error", {
expect_error(OPprob2(x))
})
OPprob2(lynx, emb=4))
OPprob2(lynx, emb=4)
OPprob2(sunspots, emb=4)
OPprob2(c(4,9,3,9,4,9), emb=3)
"
OPprob2(0, emb=3)
OPprob2( emb=3)
test_that("Test whether missing time series returns an error", {
expect_error(OPprob2(emb=5))
})
test_that("Test  whether an incorrect method input returns an error", {
expect_error(entropy(op.wn.4,"Fischer"))
})
test_that("Test  whether missing p returns an error", {
expect_error(entropy(method="Fischer"))
})
