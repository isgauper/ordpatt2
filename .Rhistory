#'
#' @name OPprob2
#'
#' @import tibble
#' @import dplyr
#' @import prodlim
#' @import ggplot2
#' @import ggthemes
#'
#' @export
#'
#' @examples
#' set.seed(1234567890, kind="Mersenne-Twister")
#' x <- rnorm(1000) # white noise
#' y <- mov.av(x, order=11) # smoothed with moving averages
#' OPprob2(x, emb=4)
#' OPprob2(y, emb=4)
utils::globalVariables("OP")
OPprob2 <- function(TS, emb, ...){
UseMethod("OPprob2")
}
# Default method
#' @export
OPprob2.default <- function(TS, emb, ...){
# TS must not contain characters
if (!all(sapply(TS, is.numeric))) {
stop("All columns in 'TS' must be numeric.")
}
# TS must not be a list
if (is.list(TS)){
stop("'TS' must not be a list")
}
if (!is.integer(emb)){
stop("'emb' must be an integer")
}
# emb must be an integer greater than 1
if (emb < 2 || !as.integer(emb)){
stop("'emb' must be greater than 1")
}
op <- tibble::tibble(
OP = factor(OPseq2(TS, emb), levels = 1:factorial(emb))
)
fr <- op %>% count(OP, .drop = FALSE)
probs <- fr$n / sum(fr$n)
result <- as.numeric(probs)
class(result) <- c("my_OPprob", "numeric")
return(result)
}
# print without method and class label
#' @export
print.my_OPprob <- function(x, ...) {
y <- as.numeric(x)
print(y)
}
# plot histogram of proportion of patterns
#' @export
plot.my_OPprob <- function(x, ...) {
# get probabilities
probs <- as.numeric(x)
# create data frame
df <- data.frame(
index = 1:length(probs),
y = probs
)
# plot histogram
p <- ggplot2::ggplot(df, aes(x = index, y = y)) +
geom_col(aes(fill="data"),col="black") +
xlab("Pattern") +
ylab("Proportion of patterns") +
ggthemes::theme_tufte() +
theme(legend.position = "none")
print(p)
}
#' Function that finds the Ordinal Patterns probabilities in a time series for a given embedding dimension
#'
#' @usage OPprob2(TS, emb)
#' @param TS time series of length \eqn{n-m+1}
#' @param emb embedding dimension \eqn{m}
#' @returns a sequence of \eqn{n} patterns
#'
#' @name OPprob2
#'
#' @import tibble
#' @import dplyr
#' @import prodlim
#' @import ggplot2
#' @import ggthemes
#'
#' @export
#'
#' @examples
#' set.seed(1234567890, kind="Mersenne-Twister")
#' x <- rnorm(1000) # white noise
#' y <- mov.av(x, order=11) # smoothed with moving averages
#' OPprob2(x, emb=4)
#' OPprob2(y, emb=4)
utils::globalVariables("OP")
OPprob2 <- function(TS, emb, ...){
UseMethod("OPprob2")
}
# Default method
#' @export
OPprob2.default <- function(TS, emb, ...){
# TS must not contain characters
if (!all(sapply(TS, is.numeric))) {
stop("All columns in 'TS' must be numeric.")
}
# TS must not be a list
if (is.list(TS)){
stop("'TS' must not be a list")
}
# emb must be an integer greater than 1
if (emb < 2 || !as.integer(emb)){
stop("'emb' must be greater than 1")
}
op <- tibble::tibble(
OP = factor(OPseq2(TS, emb), levels = 1:factorial(emb))
)
fr <- op %>% count(OP, .drop = FALSE)
probs <- fr$n / sum(fr$n)
result <- as.numeric(probs)
class(result) <- c("my_OPprob", "numeric")
return(result)
}
# print without method and class label
#' @export
print.my_OPprob <- function(x, ...) {
y <- as.numeric(x)
print(y)
}
# plot histogram of proportion of patterns
#' @export
plot.my_OPprob <- function(x, ...) {
# get probabilities
probs <- as.numeric(x)
# create data frame
df <- data.frame(
index = 1:length(probs),
y = probs
)
# plot histogram
p <- ggplot2::ggplot(df, aes(x = index, y = y)) +
geom_col(aes(fill="data"),col="black") +
xlab("Pattern") +
ylab("Proportion of patterns") +
ggthemes::theme_tufte() +
theme(legend.position = "none")
print(p)
}
OPprob2(lynx,3)
OPprob2(lynx,3.5)
as.integer(3.5)
#' Function that finds the Ordinal Patterns probabilities in a time series for a given embedding dimension
#'
#' @usage OPprob2(TS, emb)
#' @param TS time series of length \eqn{n-m+1}
#' @param emb embedding dimension \eqn{m}
#' @returns a sequence of \eqn{n} patterns
#'
#' @name OPprob2
#'
#' @import tibble
#' @import dplyr
#' @import prodlim
#' @import ggplot2
#' @import ggthemes
#'
#' @export
#'
#' @examples
#' set.seed(1234567890, kind="Mersenne-Twister")
#' x <- rnorm(1000) # white noise
#' y <- mov.av(x, order=11) # smoothed with moving averages
#' OPprob2(x, emb=4)
#' OPprob2(y, emb=4)
utils::globalVariables("OP")
OPprob2 <- function(TS, emb, ...){
UseMethod("OPprob2")
}
# Default method
#' @export
OPprob2.default <- function(TS, emb, ...){
# TS must not contain characters
if (!all(sapply(TS, is.numeric))) {
stop("All columns in 'TS' must be numeric.")
}
# TS must not be a list
if (is.list(TS)){
stop("'TS' must not be a list")
}
# emb must be an integer greater than 1
if (emb < 2 || emb %% 1 != 0){
stop("'emb' must be greater than 1")
}
op <- tibble::tibble(
OP = factor(OPseq2(TS, emb), levels = 1:factorial(emb))
)
fr <- op %>% count(OP, .drop = FALSE)
probs <- fr$n / sum(fr$n)
result <- as.numeric(probs)
class(result) <- c("my_OPprob", "numeric")
return(result)
}
# print without method and class label
#' @export
print.my_OPprob <- function(x, ...) {
y <- as.numeric(x)
print(y)
}
# plot histogram of proportion of patterns
#' @export
plot.my_OPprob <- function(x, ...) {
# get probabilities
probs <- as.numeric(x)
# create data frame
df <- data.frame(
index = 1:length(probs),
y = probs
)
# plot histogram
p <- ggplot2::ggplot(df, aes(x = index, y = y)) +
geom_col(aes(fill="data"),col="black") +
xlab("Pattern") +
ylab("Proportion of patterns") +
ggthemes::theme_tufte() +
theme(legend.position = "none")
print(p)
}
OPprob2(lynx,3.5)
#' Function that finds the Ordinal Patterns probabilities in a time series for a given embedding dimension
#'
#' @usage OPprob2(TS, emb)
#' @param TS time series of length \eqn{n-m+1}
#' @param emb embedding dimension \eqn{m}
#' @returns a sequence of \eqn{n} patterns
#'
#' @name OPprob2
#'
#' @import tibble
#' @import dplyr
#' @import prodlim
#' @import ggplot2
#' @import ggthemes
#'
#' @export
#'
#' @examples
#' set.seed(1234567890, kind="Mersenne-Twister")
#' x <- rnorm(1000) # white noise
#' y <- mov.av(x, order=11) # smoothed with moving averages
#' OPprob2(x, emb=4)
#' OPprob2(y, emb=4)
utils::globalVariables("OP")
OPprob2 <- function(TS, emb, ...){
UseMethod("OPprob2")
}
# Default method
#' @export
OPprob2.default <- function(TS, emb, ...){
# TS must not contain characters
if (!all(sapply(TS, is.numeric))) {
stop("All columns in 'TS' must be numeric.")
}
# TS must not be a list
if (is.list(TS)){
stop("'TS' must not be a list")
}
# emb must be an integer greater than 1
if (emb < 2 ){
stop("'emb' must be greater than 1")
}
# emb must be an integer
if ( emb %% 1 != 0){
stop("'emb' must be an integer")
}
op <- tibble::tibble(
OP = factor(OPseq2(TS, emb), levels = 1:factorial(emb))
)
fr <- op %>% count(OP, .drop = FALSE)
probs <- fr$n / sum(fr$n)
result <- as.numeric(probs)
class(result) <- c("my_OPprob", "numeric")
return(result)
}
# print without method and class label
#' @export
print.my_OPprob <- function(x, ...) {
y <- as.numeric(x)
print(y)
}
# plot histogram of proportion of patterns
#' @export
plot.my_OPprob <- function(x, ...) {
# get probabilities
probs <- as.numeric(x)
# create data frame
df <- data.frame(
index = 1:length(probs),
y = probs
)
# plot histogram
p <- ggplot2::ggplot(df, aes(x = index, y = y)) +
geom_col(aes(fill="data"),col="black") +
xlab("Pattern") +
ylab("Proportion of patterns") +
ggthemes::theme_tufte() +
theme(legend.position = "none")
print(p)
}
OPprob2(lynx,3.5)
OPprob2(lynx,3)
OPprob(lynx,3)
OPprob(lynx,3.5)
#' Unit tests for the OPprob2 function
test_that("Test whether outputs are the same as StatOrdPattHxC", {
expect_equal(
as.numeric(OPprob2(x, emb=4)),
StatOrdPattHxC::OPprob(x, emb=4)
)
expect_equal(
as.numeric(OPprob2(x, emb=5)),
StatOrdPattHxC::OPprob(x, emb=5)
)
})
test_that("Test whether missing embedding dimension returns an error", {
expect_error(OPprob2(x))
})
test_that("Test whether missing time series returns an error", {
expect_error(OPprob2(emb=5))
})
test_that("Test for error if emb < 2", {
expect_error(OPprob2(x, emb=1), "'emb' must be greater than 1" )
})
#' Unit tests for the OPprob2 function
test_that("Test whether outputs are the same as StatOrdPattHxC", {
expect_equal(
as.numeric(OPprob2(x, emb=4)),
StatOrdPattHxC::OPprob(x, emb=4)
)
expect_equal(
as.numeric(OPprob2(x, emb=5)),
StatOrdPattHxC::OPprob(x, emb=5)
)
})
test_that("Test whether missing embedding dimension returns an error", {
expect_error(OPprob2(x))
})
test_that("Test whether missing time series returns an error", {
expect_error(OPprob2(emb=5))
})
test_that("Test for error if emb < 2", {
expect_error(OPprob2(x, emb=1), "'emb' must be greater than 1" )
})
test_that("Test for error if emb is not a whole number", {
expect_error(OPprob2(x, emb=2.5), "'emb' must be an integer")
})
#' Function that finds the OP sequence of a time series, given the
#' embedding dimension and lag
#'
#' @param TS time series
#' @param emb embedding dimension
#' @param lag time lag (default value: 1)
#'
#' @importFrom stats rnorm
#' @export
#'
#' @examples
#' # Generate a time series and compute its ordinal patterns
#' set.seed(1234567890, kind="Mersenne-Twister")
#' x <- rnorm(1000) # white noise
#' OPseq2(x, emb=4, lag=1)
#'
OPseq2 <- function(TS, emb, lag=1){
# TS must not contain characters
if (!all(sapply(TS, is.numeric))) {
stop("All columns in 'TS' must be numeric.")
}
# TS must not be a list
if (is.list(TS)){
stop("'TS' must not be a list")
# emb must be greater than 1
if (emb < 2 ){
stop("'emb' must be greater than 1")
}
# emb must be an integer
if ( emb %% 1 != 0){
stop("'emb' must be an integer")
}
# lag must be greater than 0
if (!(lag > 0) ){
stop("'lag' must be greater than 0")
}
# lag must be an integer
if ( lag %% 1 != 0){
stop("'lag' must be an integer")
}
# number of OP for lag = 1
el <- length(TS) - emb + 1
# OP sequence for lag = 1
seqOP <- vector()
for (i in 1:el){
seqOP[i] <- pi_i2(ind_pos(TS[i:(i + emb - 1)]))
}
# OP sequence for the given lag
return(seqOP[seq(1, el, lag)])
}
set.seed(1234567890, kind="Mersenne-Twister")
x <- rnorm(1000) # white noise
OPseq2 <- function(TS, emb, lag=1){
# TS must not contain characters
if (!all(sapply(TS, is.numeric))) {
stop("All columns in 'TS' must be numeric.")
}
# TS must not be a list
if (is.list(TS)){
stop("'TS' must not be a list")
}
# emb must be greater than 1
if (emb < 2 ){
stop("'emb' must be greater than 1")
}
# emb must be an integer
if ( emb %% 1 != 0){
stop("'emb' must be an integer")
}
# lag must be greater than 0
if (!(lag > 0) ){
stop("'lag' must be greater than 0")
}
# lag must be an integer
if ( lag %% 1 != 0){
stop("'lag' must be an integer")
}
# number of OP for lag = 1
el <- length(TS) - emb + 1
# OP sequence for lag = 1
seqOP <- vector()
for (i in 1:el){
seqOP[i] <- pi_i2(ind_pos(TS[i:(i + emb - 1)]))
}
# OP sequence for the given lag
return(seqOP[seq(1, el, lag)])
}
set.seed(1234567890, kind="Mersenne-Twister")
x <- rnorm(1000) # white noise
OPseq2(x, emb=4, lag=1)
ind_pos <- function(part){
v <- sort(unique(part))
count <- 0
pos <- vector()
for (i in 1:length(v)){
id <- which(part == v[i])
for (j in 1:length(id)){
count <- count + 1
pos[id[j]] <- count
}
}
return(pos-1)
}
OPseq2(x, emb=4, lag=1)
OPseq2(x, emb=4, lag=1) -> op2
OPseq(x, emb=4, lag=1) -> op
sum(op2 != op)
sum(op2 == op)
length(op2)
length(op)
OPseq(lynx, emb=4, lag=1) -> op
OPseq2(lynx, emb=4, lag=1) -> op
OPseq2(lynx, emb=4, lag=0)
OPseq(lynx, emb=4, lag=0)
OPseq(lynx, emb=4, lag=-1)
OPseq(lynx, emb=4, lag=-1)
OPseq2(lynx, emb=4, lag=-1)
OPseq2(lynx, emb=4, lag=-1.5)
OPseq2(lynx, emb=4, lag=1.5)
OPseq(lynx, emb=4, lag=1.5)
OPseq(lynx, emb=4)
?OPseq
OPseq(lynx, emb=-4)
OPseq2(lynx, emb=-4)
OPseq2(lynx)
OPseq2(emb=4)
test_that("Test for error if emb < 2", {
expect_error(OPseq2(x, emb=1), "'emb' must be greater than 1" )
})
test_that("Test whether missing time series returns an error", {
expect_error(OPseq2(emb=5))
})
test_that("Test whether missing embedding dimension returns an error", {
expect_error(OPseq2(x))
})
test_that("Test for error if emb is not a whole number", {
expect_error(OPseq2(x, emb=2.5), "'emb' must be an integer")
})
rbind(1:4, c("A","b","c","d"))
cbind(1:4, c("A","b","c","d"))
test_that("Tet for error if all columns in TS are not numeric", {
expect_error(OPseq2(cbind(1:4, c("A","b","c","d")),emb=2), "All columns in 'TS' must be numeric.")
})
test_that("Test for error if TS is a list", {
expect_error(OPseq2(list(lynx),emb=2,lag=2), "'TS' must not be a list")
})
test_that("Test for error if all columns in TS are not numeric", {
expect_error(OPprob2(cbind(1:4, c("A","b","c","d")),emb=2), "All columns in 'TS' must be numeric.")
})
test_that("Test for error if TS is a list", {
expect_error(OPprob2(list(lynx),emb=2), "'TS' must not be a list")
})
usethis::use_testthat()
setwd("~/ordpatt2_pkg/ordpatt2")
usethis::use_testthat()
usethis::use_testthat()
